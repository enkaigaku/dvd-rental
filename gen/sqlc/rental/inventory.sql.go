// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package rentalsqlc

import (
	"context"
)

const countAvailableInventory = `-- name: CountAvailableInventory :one
SELECT count(*)
FROM inventory i
WHERE i.film_id = $1
  AND i.store_id = $2
  AND NOT EXISTS (
      SELECT 1 FROM rental r
      WHERE r.inventory_id = i.inventory_id AND r.return_date IS NULL
  )
`

type CountAvailableInventoryParams struct {
	FilmID  int32 `json:"film_id"`
	StoreID int32 `json:"store_id"`
}

func (q *Queries) CountAvailableInventory(ctx context.Context, arg CountAvailableInventoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableInventory, arg.FilmID, arg.StoreID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInventory = `-- name: CountInventory :one
SELECT count(*) FROM inventory
`

func (q *Queries) CountInventory(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countInventory)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInventoryByFilm = `-- name: CountInventoryByFilm :one
SELECT count(*) FROM inventory WHERE film_id = $1
`

func (q *Queries) CountInventoryByFilm(ctx context.Context, filmID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countInventoryByFilm, filmID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInventoryByStore = `-- name: CountInventoryByStore :one
SELECT count(*) FROM inventory WHERE store_id = $1
`

func (q *Queries) CountInventoryByStore(ctx context.Context, storeID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countInventoryByStore, storeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInventory = `-- name: CreateInventory :one
INSERT INTO inventory (film_id, store_id)
VALUES ($1, $2)
RETURNING inventory_id, film_id, store_id, last_update
`

type CreateInventoryParams struct {
	FilmID  int32 `json:"film_id"`
	StoreID int32 `json:"store_id"`
}

func (q *Queries) CreateInventory(ctx context.Context, arg CreateInventoryParams) (Inventory, error) {
	row := q.db.QueryRow(ctx, createInventory, arg.FilmID, arg.StoreID)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.FilmID,
		&i.StoreID,
		&i.LastUpdate,
	)
	return i, err
}

const deleteInventory = `-- name: DeleteInventory :exec
DELETE FROM inventory WHERE inventory_id = $1
`

func (q *Queries) DeleteInventory(ctx context.Context, inventoryID int32) error {
	_, err := q.db.Exec(ctx, deleteInventory, inventoryID)
	return err
}

const getInventory = `-- name: GetInventory :one
SELECT inventory_id, film_id, store_id, last_update
FROM inventory
WHERE inventory_id = $1
`

func (q *Queries) GetInventory(ctx context.Context, inventoryID int32) (Inventory, error) {
	row := q.db.QueryRow(ctx, getInventory, inventoryID)
	var i Inventory
	err := row.Scan(
		&i.InventoryID,
		&i.FilmID,
		&i.StoreID,
		&i.LastUpdate,
	)
	return i, err
}

const listAvailableInventory = `-- name: ListAvailableInventory :many
SELECT i.inventory_id, i.film_id, i.store_id, i.last_update
FROM inventory i
WHERE i.film_id = $1
  AND i.store_id = $2
  AND NOT EXISTS (
      SELECT 1 FROM rental r
      WHERE r.inventory_id = i.inventory_id AND r.return_date IS NULL
  )
ORDER BY i.inventory_id
LIMIT $3 OFFSET $4
`

type ListAvailableInventoryParams struct {
	FilmID  int32 `json:"film_id"`
	StoreID int32 `json:"store_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListAvailableInventory(ctx context.Context, arg ListAvailableInventoryParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listAvailableInventory,
		arg.FilmID,
		arg.StoreID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.InventoryID,
			&i.FilmID,
			&i.StoreID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventory = `-- name: ListInventory :many
SELECT inventory_id, film_id, store_id, last_update
FROM inventory
ORDER BY inventory_id
LIMIT $1 OFFSET $2
`

type ListInventoryParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListInventory(ctx context.Context, arg ListInventoryParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listInventory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.InventoryID,
			&i.FilmID,
			&i.StoreID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryByFilm = `-- name: ListInventoryByFilm :many
SELECT inventory_id, film_id, store_id, last_update
FROM inventory
WHERE film_id = $1
ORDER BY inventory_id
LIMIT $2 OFFSET $3
`

type ListInventoryByFilmParams struct {
	FilmID int32 `json:"film_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListInventoryByFilm(ctx context.Context, arg ListInventoryByFilmParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listInventoryByFilm, arg.FilmID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.InventoryID,
			&i.FilmID,
			&i.StoreID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryByStore = `-- name: ListInventoryByStore :many
SELECT inventory_id, film_id, store_id, last_update
FROM inventory
WHERE store_id = $1
ORDER BY inventory_id
LIMIT $2 OFFSET $3
`

type ListInventoryByStoreParams struct {
	StoreID int32 `json:"store_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListInventoryByStore(ctx context.Context, arg ListInventoryByStoreParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listInventoryByStore, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.InventoryID,
			&i.FilmID,
			&i.StoreID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
