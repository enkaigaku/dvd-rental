// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rental.sql

package rentalsqlc

import (
	"context"
)

const countOverdueRentals = `-- name: CountOverdueRentals :one
SELECT count(*) FROM rental WHERE return_date IS NULL
`

func (q *Queries) CountOverdueRentals(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOverdueRentals)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRentals = `-- name: CountRentals :one
SELECT count(*) FROM rental
`

func (q *Queries) CountRentals(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRentals)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRentalsByCustomer = `-- name: CountRentalsByCustomer :one
SELECT count(*) FROM rental WHERE customer_id = $1
`

func (q *Queries) CountRentalsByCustomer(ctx context.Context, customerID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countRentalsByCustomer, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRentalsByInventory = `-- name: CountRentalsByInventory :one
SELECT count(*) FROM rental WHERE inventory_id = $1
`

func (q *Queries) CountRentalsByInventory(ctx context.Context, inventoryID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countRentalsByInventory, inventoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRental = `-- name: CreateRental :one
INSERT INTO rental (rental_date, inventory_id, customer_id, staff_id)
VALUES (now(), $1, $2, $3)
RETURNING rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update
`

type CreateRentalParams struct {
	InventoryID int32 `json:"inventory_id"`
	CustomerID  int32 `json:"customer_id"`
	StaffID     int32 `json:"staff_id"`
}

func (q *Queries) CreateRental(ctx context.Context, arg CreateRentalParams) (Rental, error) {
	row := q.db.QueryRow(ctx, createRental, arg.InventoryID, arg.CustomerID, arg.StaffID)
	var i Rental
	err := row.Scan(
		&i.RentalID,
		&i.RentalDate,
		&i.InventoryID,
		&i.CustomerID,
		&i.ReturnDate,
		&i.StaffID,
		&i.LastUpdate,
	)
	return i, err
}

const deleteRental = `-- name: DeleteRental :exec
DELETE FROM rental WHERE rental_id = $1
`

func (q *Queries) DeleteRental(ctx context.Context, rentalID int32) error {
	_, err := q.db.Exec(ctx, deleteRental, rentalID)
	return err
}

const getCustomerName = `-- name: GetCustomerName :one
SELECT first_name || ' ' || last_name AS full_name
FROM customer
WHERE customer_id = $1
`

func (q *Queries) GetCustomerName(ctx context.Context, customerID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getCustomerName, customerID)
	var full_name interface{}
	err := row.Scan(&full_name)
	return full_name, err
}

const getFilmTitleByInventory = `-- name: GetFilmTitleByInventory :one
SELECT f.title, i.store_id
FROM inventory i
JOIN film f ON f.film_id = i.film_id
WHERE i.inventory_id = $1
`

type GetFilmTitleByInventoryRow struct {
	Title   string `json:"title"`
	StoreID int32  `json:"store_id"`
}

func (q *Queries) GetFilmTitleByInventory(ctx context.Context, inventoryID int32) (GetFilmTitleByInventoryRow, error) {
	row := q.db.QueryRow(ctx, getFilmTitleByInventory, inventoryID)
	var i GetFilmTitleByInventoryRow
	err := row.Scan(&i.Title, &i.StoreID)
	return i, err
}

const getRental = `-- name: GetRental :one
SELECT rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update
FROM rental
WHERE rental_id = $1
`

func (q *Queries) GetRental(ctx context.Context, rentalID int32) (Rental, error) {
	row := q.db.QueryRow(ctx, getRental, rentalID)
	var i Rental
	err := row.Scan(
		&i.RentalID,
		&i.RentalDate,
		&i.InventoryID,
		&i.CustomerID,
		&i.ReturnDate,
		&i.StaffID,
		&i.LastUpdate,
	)
	return i, err
}

const isInventoryAvailable = `-- name: IsInventoryAvailable :one
SELECT NOT EXISTS (
    SELECT 1 FROM rental
    WHERE inventory_id = $1 AND return_date IS NULL
) AS available
`

func (q *Queries) IsInventoryAvailable(ctx context.Context, inventoryID int32) (bool, error) {
	row := q.db.QueryRow(ctx, isInventoryAvailable, inventoryID)
	var available bool
	err := row.Scan(&available)
	return available, err
}

const listOverdueRentals = `-- name: ListOverdueRentals :many
SELECT rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update
FROM rental
WHERE return_date IS NULL
ORDER BY rental_date ASC
LIMIT $1 OFFSET $2
`

type ListOverdueRentalsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListOverdueRentals(ctx context.Context, arg ListOverdueRentalsParams) ([]Rental, error) {
	rows, err := q.db.Query(ctx, listOverdueRentals, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Rental{}
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.RentalID,
			&i.RentalDate,
			&i.InventoryID,
			&i.CustomerID,
			&i.ReturnDate,
			&i.StaffID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRentals = `-- name: ListRentals :many
SELECT rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update
FROM rental
ORDER BY rental_id DESC
LIMIT $1 OFFSET $2
`

type ListRentalsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRentals(ctx context.Context, arg ListRentalsParams) ([]Rental, error) {
	rows, err := q.db.Query(ctx, listRentals, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Rental{}
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.RentalID,
			&i.RentalDate,
			&i.InventoryID,
			&i.CustomerID,
			&i.ReturnDate,
			&i.StaffID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRentalsByCustomer = `-- name: ListRentalsByCustomer :many
SELECT rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update
FROM rental
WHERE customer_id = $1
ORDER BY rental_id DESC
LIMIT $2 OFFSET $3
`

type ListRentalsByCustomerParams struct {
	CustomerID int32 `json:"customer_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListRentalsByCustomer(ctx context.Context, arg ListRentalsByCustomerParams) ([]Rental, error) {
	rows, err := q.db.Query(ctx, listRentalsByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Rental{}
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.RentalID,
			&i.RentalDate,
			&i.InventoryID,
			&i.CustomerID,
			&i.ReturnDate,
			&i.StaffID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRentalsByInventory = `-- name: ListRentalsByInventory :many
SELECT rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update
FROM rental
WHERE inventory_id = $1
ORDER BY rental_id DESC
LIMIT $2 OFFSET $3
`

type ListRentalsByInventoryParams struct {
	InventoryID int32 `json:"inventory_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

func (q *Queries) ListRentalsByInventory(ctx context.Context, arg ListRentalsByInventoryParams) ([]Rental, error) {
	rows, err := q.db.Query(ctx, listRentalsByInventory, arg.InventoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Rental{}
	for rows.Next() {
		var i Rental
		if err := rows.Scan(
			&i.RentalID,
			&i.RentalDate,
			&i.InventoryID,
			&i.CustomerID,
			&i.ReturnDate,
			&i.StaffID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnRental = `-- name: ReturnRental :one
UPDATE rental
SET return_date = now()
WHERE rental_id = $1 AND return_date IS NULL
RETURNING rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update
`

func (q *Queries) ReturnRental(ctx context.Context, rentalID int32) (Rental, error) {
	row := q.db.QueryRow(ctx, returnRental, rentalID)
	var i Rental
	err := row.Scan(
		&i.RentalID,
		&i.RentalDate,
		&i.InventoryID,
		&i.CustomerID,
		&i.ReturnDate,
		&i.StaffID,
		&i.LastUpdate,
	)
	return i, err
}
