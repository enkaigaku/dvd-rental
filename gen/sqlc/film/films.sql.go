// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: films.sql

package filmsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFilms = `-- name: CountFilms :one
SELECT count(*) FROM film
`

func (q *Queries) CountFilms(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFilms)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilmsByActor = `-- name: CountFilmsByActor :one
SELECT count(*)
FROM film f
JOIN film_actor fa ON f.film_id = fa.film_id
WHERE fa.actor_id = $1
`

func (q *Queries) CountFilmsByActor(ctx context.Context, actorID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countFilmsByActor, actorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilmsByCategory = `-- name: CountFilmsByCategory :one
SELECT count(*)
FROM film f
JOIN film_category fc ON f.film_id = fc.film_id
WHERE fc.category_id = $1
`

func (q *Queries) CountFilmsByCategory(ctx context.Context, categoryID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countFilmsByCategory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchFilms = `-- name: CountSearchFilms :one
SELECT count(*)
FROM film
WHERE fulltext @@ plainto_tsquery('english', $1)
`

func (q *Queries) CountSearchFilms(ctx context.Context, plaintoTsquery string) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchFilms, plaintoTsquery)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFilm = `-- name: CreateFilm :one
INSERT INTO film (title, description, release_year, language_id,
                  original_language_id, rental_duration, rental_rate,
                  length, replacement_cost, rating, special_features)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING film_id, title, description, release_year, language_id,
          original_language_id, rental_duration, rental_rate, length,
          replacement_cost, rating, special_features, last_update
`

type CreateFilmParams struct {
	Title              string         `json:"title"`
	Description        pgtype.Text    `json:"description"`
	ReleaseYear        interface{}    `json:"release_year"`
	LanguageID         int32          `json:"language_id"`
	OriginalLanguageID pgtype.Int4    `json:"original_language_id"`
	RentalDuration     int16          `json:"rental_duration"`
	RentalRate         pgtype.Numeric `json:"rental_rate"`
	Length             pgtype.Int2    `json:"length"`
	ReplacementCost    pgtype.Numeric `json:"replacement_cost"`
	Rating             NullMpaaRating `json:"rating"`
	SpecialFeatures    []string       `json:"special_features"`
}

type CreateFilmRow struct {
	FilmID             int32              `json:"film_id"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	ReleaseYear        interface{}        `json:"release_year"`
	LanguageID         int32              `json:"language_id"`
	OriginalLanguageID pgtype.Int4        `json:"original_language_id"`
	RentalDuration     int16              `json:"rental_duration"`
	RentalRate         pgtype.Numeric     `json:"rental_rate"`
	Length             pgtype.Int2        `json:"length"`
	ReplacementCost    pgtype.Numeric     `json:"replacement_cost"`
	Rating             NullMpaaRating     `json:"rating"`
	SpecialFeatures    []string           `json:"special_features"`
	LastUpdate         pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) CreateFilm(ctx context.Context, arg CreateFilmParams) (CreateFilmRow, error) {
	row := q.db.QueryRow(ctx, createFilm,
		arg.Title,
		arg.Description,
		arg.ReleaseYear,
		arg.LanguageID,
		arg.OriginalLanguageID,
		arg.RentalDuration,
		arg.RentalRate,
		arg.Length,
		arg.ReplacementCost,
		arg.Rating,
		arg.SpecialFeatures,
	)
	var i CreateFilmRow
	err := row.Scan(
		&i.FilmID,
		&i.Title,
		&i.Description,
		&i.ReleaseYear,
		&i.LanguageID,
		&i.OriginalLanguageID,
		&i.RentalDuration,
		&i.RentalRate,
		&i.Length,
		&i.ReplacementCost,
		&i.Rating,
		&i.SpecialFeatures,
		&i.LastUpdate,
	)
	return i, err
}

const deleteFilm = `-- name: DeleteFilm :exec
DELETE FROM film WHERE film_id = $1
`

func (q *Queries) DeleteFilm(ctx context.Context, filmID int32) error {
	_, err := q.db.Exec(ctx, deleteFilm, filmID)
	return err
}

const getFilm = `-- name: GetFilm :one
SELECT film_id, title, description, release_year, language_id,
       original_language_id, rental_duration, rental_rate, length,
       replacement_cost, rating, special_features, last_update
FROM film
WHERE film_id = $1
`

type GetFilmRow struct {
	FilmID             int32              `json:"film_id"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	ReleaseYear        interface{}        `json:"release_year"`
	LanguageID         int32              `json:"language_id"`
	OriginalLanguageID pgtype.Int4        `json:"original_language_id"`
	RentalDuration     int16              `json:"rental_duration"`
	RentalRate         pgtype.Numeric     `json:"rental_rate"`
	Length             pgtype.Int2        `json:"length"`
	ReplacementCost    pgtype.Numeric     `json:"replacement_cost"`
	Rating             NullMpaaRating     `json:"rating"`
	SpecialFeatures    []string           `json:"special_features"`
	LastUpdate         pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) GetFilm(ctx context.Context, filmID int32) (GetFilmRow, error) {
	row := q.db.QueryRow(ctx, getFilm, filmID)
	var i GetFilmRow
	err := row.Scan(
		&i.FilmID,
		&i.Title,
		&i.Description,
		&i.ReleaseYear,
		&i.LanguageID,
		&i.OriginalLanguageID,
		&i.RentalDuration,
		&i.RentalRate,
		&i.Length,
		&i.ReplacementCost,
		&i.Rating,
		&i.SpecialFeatures,
		&i.LastUpdate,
	)
	return i, err
}

const listFilms = `-- name: ListFilms :many
SELECT film_id, title, description, release_year, language_id,
       original_language_id, rental_duration, rental_rate, length,
       replacement_cost, rating, special_features, last_update
FROM film
ORDER BY title
LIMIT $1 OFFSET $2
`

type ListFilmsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFilmsRow struct {
	FilmID             int32              `json:"film_id"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	ReleaseYear        interface{}        `json:"release_year"`
	LanguageID         int32              `json:"language_id"`
	OriginalLanguageID pgtype.Int4        `json:"original_language_id"`
	RentalDuration     int16              `json:"rental_duration"`
	RentalRate         pgtype.Numeric     `json:"rental_rate"`
	Length             pgtype.Int2        `json:"length"`
	ReplacementCost    pgtype.Numeric     `json:"replacement_cost"`
	Rating             NullMpaaRating     `json:"rating"`
	SpecialFeatures    []string           `json:"special_features"`
	LastUpdate         pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) ListFilms(ctx context.Context, arg ListFilmsParams) ([]ListFilmsRow, error) {
	rows, err := q.db.Query(ctx, listFilms, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilmsRow{}
	for rows.Next() {
		var i ListFilmsRow
		if err := rows.Scan(
			&i.FilmID,
			&i.Title,
			&i.Description,
			&i.ReleaseYear,
			&i.LanguageID,
			&i.OriginalLanguageID,
			&i.RentalDuration,
			&i.RentalRate,
			&i.Length,
			&i.ReplacementCost,
			&i.Rating,
			&i.SpecialFeatures,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilmsByActor = `-- name: ListFilmsByActor :many
SELECT f.film_id, f.title, f.description, f.release_year, f.language_id,
       f.original_language_id, f.rental_duration, f.rental_rate, f.length,
       f.replacement_cost, f.rating, f.special_features, f.last_update
FROM film f
JOIN film_actor fa ON f.film_id = fa.film_id
WHERE fa.actor_id = $1
ORDER BY f.title
LIMIT $2 OFFSET $3
`

type ListFilmsByActorParams struct {
	ActorID int32 `json:"actor_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type ListFilmsByActorRow struct {
	FilmID             int32              `json:"film_id"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	ReleaseYear        interface{}        `json:"release_year"`
	LanguageID         int32              `json:"language_id"`
	OriginalLanguageID pgtype.Int4        `json:"original_language_id"`
	RentalDuration     int16              `json:"rental_duration"`
	RentalRate         pgtype.Numeric     `json:"rental_rate"`
	Length             pgtype.Int2        `json:"length"`
	ReplacementCost    pgtype.Numeric     `json:"replacement_cost"`
	Rating             NullMpaaRating     `json:"rating"`
	SpecialFeatures    []string           `json:"special_features"`
	LastUpdate         pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) ListFilmsByActor(ctx context.Context, arg ListFilmsByActorParams) ([]ListFilmsByActorRow, error) {
	rows, err := q.db.Query(ctx, listFilmsByActor, arg.ActorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilmsByActorRow{}
	for rows.Next() {
		var i ListFilmsByActorRow
		if err := rows.Scan(
			&i.FilmID,
			&i.Title,
			&i.Description,
			&i.ReleaseYear,
			&i.LanguageID,
			&i.OriginalLanguageID,
			&i.RentalDuration,
			&i.RentalRate,
			&i.Length,
			&i.ReplacementCost,
			&i.Rating,
			&i.SpecialFeatures,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilmsByCategory = `-- name: ListFilmsByCategory :many
SELECT f.film_id, f.title, f.description, f.release_year, f.language_id,
       f.original_language_id, f.rental_duration, f.rental_rate, f.length,
       f.replacement_cost, f.rating, f.special_features, f.last_update
FROM film f
JOIN film_category fc ON f.film_id = fc.film_id
WHERE fc.category_id = $1
ORDER BY f.title
LIMIT $2 OFFSET $3
`

type ListFilmsByCategoryParams struct {
	CategoryID int32 `json:"category_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type ListFilmsByCategoryRow struct {
	FilmID             int32              `json:"film_id"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	ReleaseYear        interface{}        `json:"release_year"`
	LanguageID         int32              `json:"language_id"`
	OriginalLanguageID pgtype.Int4        `json:"original_language_id"`
	RentalDuration     int16              `json:"rental_duration"`
	RentalRate         pgtype.Numeric     `json:"rental_rate"`
	Length             pgtype.Int2        `json:"length"`
	ReplacementCost    pgtype.Numeric     `json:"replacement_cost"`
	Rating             NullMpaaRating     `json:"rating"`
	SpecialFeatures    []string           `json:"special_features"`
	LastUpdate         pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) ListFilmsByCategory(ctx context.Context, arg ListFilmsByCategoryParams) ([]ListFilmsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listFilmsByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilmsByCategoryRow{}
	for rows.Next() {
		var i ListFilmsByCategoryRow
		if err := rows.Scan(
			&i.FilmID,
			&i.Title,
			&i.Description,
			&i.ReleaseYear,
			&i.LanguageID,
			&i.OriginalLanguageID,
			&i.RentalDuration,
			&i.RentalRate,
			&i.Length,
			&i.ReplacementCost,
			&i.Rating,
			&i.SpecialFeatures,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFilms = `-- name: SearchFilms :many
SELECT film_id, title, description, release_year, language_id,
       original_language_id, rental_duration, rental_rate, length,
       replacement_cost, rating, special_features, last_update
FROM film
WHERE fulltext @@ plainto_tsquery('english', $1)
ORDER BY ts_rank(fulltext, plainto_tsquery('english', $1)) DESC
LIMIT $2 OFFSET $3
`

type SearchFilmsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

type SearchFilmsRow struct {
	FilmID             int32              `json:"film_id"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	ReleaseYear        interface{}        `json:"release_year"`
	LanguageID         int32              `json:"language_id"`
	OriginalLanguageID pgtype.Int4        `json:"original_language_id"`
	RentalDuration     int16              `json:"rental_duration"`
	RentalRate         pgtype.Numeric     `json:"rental_rate"`
	Length             pgtype.Int2        `json:"length"`
	ReplacementCost    pgtype.Numeric     `json:"replacement_cost"`
	Rating             NullMpaaRating     `json:"rating"`
	SpecialFeatures    []string           `json:"special_features"`
	LastUpdate         pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) SearchFilms(ctx context.Context, arg SearchFilmsParams) ([]SearchFilmsRow, error) {
	rows, err := q.db.Query(ctx, searchFilms, arg.PlaintoTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchFilmsRow{}
	for rows.Next() {
		var i SearchFilmsRow
		if err := rows.Scan(
			&i.FilmID,
			&i.Title,
			&i.Description,
			&i.ReleaseYear,
			&i.LanguageID,
			&i.OriginalLanguageID,
			&i.RentalDuration,
			&i.RentalRate,
			&i.Length,
			&i.ReplacementCost,
			&i.Rating,
			&i.SpecialFeatures,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFilm = `-- name: UpdateFilm :one
UPDATE film
SET title = $2, description = $3, release_year = $4, language_id = $5,
    original_language_id = $6, rental_duration = $7, rental_rate = $8,
    length = $9, replacement_cost = $10, rating = $11, special_features = $12
WHERE film_id = $1
RETURNING film_id, title, description, release_year, language_id,
          original_language_id, rental_duration, rental_rate, length,
          replacement_cost, rating, special_features, last_update
`

type UpdateFilmParams struct {
	FilmID             int32          `json:"film_id"`
	Title              string         `json:"title"`
	Description        pgtype.Text    `json:"description"`
	ReleaseYear        interface{}    `json:"release_year"`
	LanguageID         int32          `json:"language_id"`
	OriginalLanguageID pgtype.Int4    `json:"original_language_id"`
	RentalDuration     int16          `json:"rental_duration"`
	RentalRate         pgtype.Numeric `json:"rental_rate"`
	Length             pgtype.Int2    `json:"length"`
	ReplacementCost    pgtype.Numeric `json:"replacement_cost"`
	Rating             NullMpaaRating `json:"rating"`
	SpecialFeatures    []string       `json:"special_features"`
}

type UpdateFilmRow struct {
	FilmID             int32              `json:"film_id"`
	Title              string             `json:"title"`
	Description        pgtype.Text        `json:"description"`
	ReleaseYear        interface{}        `json:"release_year"`
	LanguageID         int32              `json:"language_id"`
	OriginalLanguageID pgtype.Int4        `json:"original_language_id"`
	RentalDuration     int16              `json:"rental_duration"`
	RentalRate         pgtype.Numeric     `json:"rental_rate"`
	Length             pgtype.Int2        `json:"length"`
	ReplacementCost    pgtype.Numeric     `json:"replacement_cost"`
	Rating             NullMpaaRating     `json:"rating"`
	SpecialFeatures    []string           `json:"special_features"`
	LastUpdate         pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) UpdateFilm(ctx context.Context, arg UpdateFilmParams) (UpdateFilmRow, error) {
	row := q.db.QueryRow(ctx, updateFilm,
		arg.FilmID,
		arg.Title,
		arg.Description,
		arg.ReleaseYear,
		arg.LanguageID,
		arg.OriginalLanguageID,
		arg.RentalDuration,
		arg.RentalRate,
		arg.Length,
		arg.ReplacementCost,
		arg.Rating,
		arg.SpecialFeatures,
	)
	var i UpdateFilmRow
	err := row.Scan(
		&i.FilmID,
		&i.Title,
		&i.Description,
		&i.ReleaseYear,
		&i.LanguageID,
		&i.OriginalLanguageID,
		&i.RentalDuration,
		&i.RentalRate,
		&i.Length,
		&i.ReplacementCost,
		&i.Rating,
		&i.SpecialFeatures,
		&i.LastUpdate,
	)
	return i, err
}
