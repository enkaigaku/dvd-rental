// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: film/v1/film.proto

package filmv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FilmService_GetFilm_FullMethodName                = "/film.v1.FilmService/GetFilm"
	FilmService_ListFilms_FullMethodName              = "/film.v1.FilmService/ListFilms"
	FilmService_SearchFilms_FullMethodName            = "/film.v1.FilmService/SearchFilms"
	FilmService_ListFilmsByCategory_FullMethodName    = "/film.v1.FilmService/ListFilmsByCategory"
	FilmService_ListFilmsByActor_FullMethodName       = "/film.v1.FilmService/ListFilmsByActor"
	FilmService_CreateFilm_FullMethodName             = "/film.v1.FilmService/CreateFilm"
	FilmService_UpdateFilm_FullMethodName             = "/film.v1.FilmService/UpdateFilm"
	FilmService_DeleteFilm_FullMethodName             = "/film.v1.FilmService/DeleteFilm"
	FilmService_AddActorToFilm_FullMethodName         = "/film.v1.FilmService/AddActorToFilm"
	FilmService_RemoveActorFromFilm_FullMethodName    = "/film.v1.FilmService/RemoveActorFromFilm"
	FilmService_AddCategoryToFilm_FullMethodName      = "/film.v1.FilmService/AddCategoryToFilm"
	FilmService_RemoveCategoryFromFilm_FullMethodName = "/film.v1.FilmService/RemoveCategoryFromFilm"
)

// FilmServiceClient is the client API for FilmService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FilmService manages films and their relationships with actors and categories.
type FilmServiceClient interface {
	GetFilm(ctx context.Context, in *GetFilmRequest, opts ...grpc.CallOption) (*FilmDetail, error)
	ListFilms(ctx context.Context, in *ListFilmsRequest, opts ...grpc.CallOption) (*ListFilmsResponse, error)
	SearchFilms(ctx context.Context, in *SearchFilmsRequest, opts ...grpc.CallOption) (*ListFilmsResponse, error)
	ListFilmsByCategory(ctx context.Context, in *ListFilmsByCategoryRequest, opts ...grpc.CallOption) (*ListFilmsResponse, error)
	ListFilmsByActor(ctx context.Context, in *ListFilmsByActorRequest, opts ...grpc.CallOption) (*ListFilmsResponse, error)
	CreateFilm(ctx context.Context, in *CreateFilmRequest, opts ...grpc.CallOption) (*Film, error)
	UpdateFilm(ctx context.Context, in *UpdateFilmRequest, opts ...grpc.CallOption) (*Film, error)
	DeleteFilm(ctx context.Context, in *DeleteFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AddActorToFilm(ctx context.Context, in *AddActorToFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveActorFromFilm(ctx context.Context, in *RemoveActorFromFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AddCategoryToFilm(ctx context.Context, in *AddCategoryToFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveCategoryFromFilm(ctx context.Context, in *RemoveCategoryFromFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type filmServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFilmServiceClient(cc grpc.ClientConnInterface) FilmServiceClient {
	return &filmServiceClient{cc}
}

func (c *filmServiceClient) GetFilm(ctx context.Context, in *GetFilmRequest, opts ...grpc.CallOption) (*FilmDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FilmDetail)
	err := c.cc.Invoke(ctx, FilmService_GetFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) ListFilms(ctx context.Context, in *ListFilmsRequest, opts ...grpc.CallOption) (*ListFilmsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilmsResponse)
	err := c.cc.Invoke(ctx, FilmService_ListFilms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) SearchFilms(ctx context.Context, in *SearchFilmsRequest, opts ...grpc.CallOption) (*ListFilmsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilmsResponse)
	err := c.cc.Invoke(ctx, FilmService_SearchFilms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) ListFilmsByCategory(ctx context.Context, in *ListFilmsByCategoryRequest, opts ...grpc.CallOption) (*ListFilmsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilmsResponse)
	err := c.cc.Invoke(ctx, FilmService_ListFilmsByCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) ListFilmsByActor(ctx context.Context, in *ListFilmsByActorRequest, opts ...grpc.CallOption) (*ListFilmsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilmsResponse)
	err := c.cc.Invoke(ctx, FilmService_ListFilmsByActor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) CreateFilm(ctx context.Context, in *CreateFilmRequest, opts ...grpc.CallOption) (*Film, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Film)
	err := c.cc.Invoke(ctx, FilmService_CreateFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) UpdateFilm(ctx context.Context, in *UpdateFilmRequest, opts ...grpc.CallOption) (*Film, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Film)
	err := c.cc.Invoke(ctx, FilmService_UpdateFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) DeleteFilm(ctx context.Context, in *DeleteFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FilmService_DeleteFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) AddActorToFilm(ctx context.Context, in *AddActorToFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FilmService_AddActorToFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) RemoveActorFromFilm(ctx context.Context, in *RemoveActorFromFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FilmService_RemoveActorFromFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) AddCategoryToFilm(ctx context.Context, in *AddCategoryToFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FilmService_AddCategoryToFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filmServiceClient) RemoveCategoryFromFilm(ctx context.Context, in *RemoveCategoryFromFilmRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FilmService_RemoveCategoryFromFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FilmServiceServer is the server API for FilmService service.
// All implementations must embed UnimplementedFilmServiceServer
// for forward compatibility.
//
// FilmService manages films and their relationships with actors and categories.
type FilmServiceServer interface {
	GetFilm(context.Context, *GetFilmRequest) (*FilmDetail, error)
	ListFilms(context.Context, *ListFilmsRequest) (*ListFilmsResponse, error)
	SearchFilms(context.Context, *SearchFilmsRequest) (*ListFilmsResponse, error)
	ListFilmsByCategory(context.Context, *ListFilmsByCategoryRequest) (*ListFilmsResponse, error)
	ListFilmsByActor(context.Context, *ListFilmsByActorRequest) (*ListFilmsResponse, error)
	CreateFilm(context.Context, *CreateFilmRequest) (*Film, error)
	UpdateFilm(context.Context, *UpdateFilmRequest) (*Film, error)
	DeleteFilm(context.Context, *DeleteFilmRequest) (*emptypb.Empty, error)
	AddActorToFilm(context.Context, *AddActorToFilmRequest) (*emptypb.Empty, error)
	RemoveActorFromFilm(context.Context, *RemoveActorFromFilmRequest) (*emptypb.Empty, error)
	AddCategoryToFilm(context.Context, *AddCategoryToFilmRequest) (*emptypb.Empty, error)
	RemoveCategoryFromFilm(context.Context, *RemoveCategoryFromFilmRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFilmServiceServer()
}

// UnimplementedFilmServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFilmServiceServer struct{}

func (UnimplementedFilmServiceServer) GetFilm(context.Context, *GetFilmRequest) (*FilmDetail, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFilm not implemented")
}
func (UnimplementedFilmServiceServer) ListFilms(context.Context, *ListFilmsRequest) (*ListFilmsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListFilms not implemented")
}
func (UnimplementedFilmServiceServer) SearchFilms(context.Context, *SearchFilmsRequest) (*ListFilmsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchFilms not implemented")
}
func (UnimplementedFilmServiceServer) ListFilmsByCategory(context.Context, *ListFilmsByCategoryRequest) (*ListFilmsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListFilmsByCategory not implemented")
}
func (UnimplementedFilmServiceServer) ListFilmsByActor(context.Context, *ListFilmsByActorRequest) (*ListFilmsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListFilmsByActor not implemented")
}
func (UnimplementedFilmServiceServer) CreateFilm(context.Context, *CreateFilmRequest) (*Film, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateFilm not implemented")
}
func (UnimplementedFilmServiceServer) UpdateFilm(context.Context, *UpdateFilmRequest) (*Film, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateFilm not implemented")
}
func (UnimplementedFilmServiceServer) DeleteFilm(context.Context, *DeleteFilmRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteFilm not implemented")
}
func (UnimplementedFilmServiceServer) AddActorToFilm(context.Context, *AddActorToFilmRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AddActorToFilm not implemented")
}
func (UnimplementedFilmServiceServer) RemoveActorFromFilm(context.Context, *RemoveActorFromFilmRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveActorFromFilm not implemented")
}
func (UnimplementedFilmServiceServer) AddCategoryToFilm(context.Context, *AddCategoryToFilmRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AddCategoryToFilm not implemented")
}
func (UnimplementedFilmServiceServer) RemoveCategoryFromFilm(context.Context, *RemoveCategoryFromFilmRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveCategoryFromFilm not implemented")
}
func (UnimplementedFilmServiceServer) mustEmbedUnimplementedFilmServiceServer() {}
func (UnimplementedFilmServiceServer) testEmbeddedByValue()                     {}

// UnsafeFilmServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FilmServiceServer will
// result in compilation errors.
type UnsafeFilmServiceServer interface {
	mustEmbedUnimplementedFilmServiceServer()
}

func RegisterFilmServiceServer(s grpc.ServiceRegistrar, srv FilmServiceServer) {
	// If the following call panics, it indicates UnimplementedFilmServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FilmService_ServiceDesc, srv)
}

func _FilmService_GetFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).GetFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_GetFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).GetFilm(ctx, req.(*GetFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_ListFilms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilmsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).ListFilms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_ListFilms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).ListFilms(ctx, req.(*ListFilmsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_SearchFilms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchFilmsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).SearchFilms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_SearchFilms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).SearchFilms(ctx, req.(*SearchFilmsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_ListFilmsByCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilmsByCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).ListFilmsByCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_ListFilmsByCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).ListFilmsByCategory(ctx, req.(*ListFilmsByCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_ListFilmsByActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilmsByActorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).ListFilmsByActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_ListFilmsByActor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).ListFilmsByActor(ctx, req.(*ListFilmsByActorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_CreateFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).CreateFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_CreateFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).CreateFilm(ctx, req.(*CreateFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_UpdateFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).UpdateFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_UpdateFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).UpdateFilm(ctx, req.(*UpdateFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_DeleteFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).DeleteFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_DeleteFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).DeleteFilm(ctx, req.(*DeleteFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_AddActorToFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddActorToFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).AddActorToFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_AddActorToFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).AddActorToFilm(ctx, req.(*AddActorToFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_RemoveActorFromFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveActorFromFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).RemoveActorFromFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_RemoveActorFromFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).RemoveActorFromFilm(ctx, req.(*RemoveActorFromFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_AddCategoryToFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCategoryToFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).AddCategoryToFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_AddCategoryToFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).AddCategoryToFilm(ctx, req.(*AddCategoryToFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilmService_RemoveCategoryFromFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCategoryFromFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilmServiceServer).RemoveCategoryFromFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilmService_RemoveCategoryFromFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilmServiceServer).RemoveCategoryFromFilm(ctx, req.(*RemoveCategoryFromFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FilmService_ServiceDesc is the grpc.ServiceDesc for FilmService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FilmService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "film.v1.FilmService",
	HandlerType: (*FilmServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFilm",
			Handler:    _FilmService_GetFilm_Handler,
		},
		{
			MethodName: "ListFilms",
			Handler:    _FilmService_ListFilms_Handler,
		},
		{
			MethodName: "SearchFilms",
			Handler:    _FilmService_SearchFilms_Handler,
		},
		{
			MethodName: "ListFilmsByCategory",
			Handler:    _FilmService_ListFilmsByCategory_Handler,
		},
		{
			MethodName: "ListFilmsByActor",
			Handler:    _FilmService_ListFilmsByActor_Handler,
		},
		{
			MethodName: "CreateFilm",
			Handler:    _FilmService_CreateFilm_Handler,
		},
		{
			MethodName: "UpdateFilm",
			Handler:    _FilmService_UpdateFilm_Handler,
		},
		{
			MethodName: "DeleteFilm",
			Handler:    _FilmService_DeleteFilm_Handler,
		},
		{
			MethodName: "AddActorToFilm",
			Handler:    _FilmService_AddActorToFilm_Handler,
		},
		{
			MethodName: "RemoveActorFromFilm",
			Handler:    _FilmService_RemoveActorFromFilm_Handler,
		},
		{
			MethodName: "AddCategoryToFilm",
			Handler:    _FilmService_AddCategoryToFilm_Handler,
		},
		{
			MethodName: "RemoveCategoryFromFilm",
			Handler:    _FilmService_RemoveCategoryFromFilm_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "film/v1/film.proto",
}

const (
	ActorService_GetActor_FullMethodName         = "/film.v1.ActorService/GetActor"
	ActorService_ListActors_FullMethodName       = "/film.v1.ActorService/ListActors"
	ActorService_ListActorsByFilm_FullMethodName = "/film.v1.ActorService/ListActorsByFilm"
	ActorService_CreateActor_FullMethodName      = "/film.v1.ActorService/CreateActor"
	ActorService_UpdateActor_FullMethodName      = "/film.v1.ActorService/UpdateActor"
	ActorService_DeleteActor_FullMethodName      = "/film.v1.ActorService/DeleteActor"
)

// ActorServiceClient is the client API for ActorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ActorService manages actors.
type ActorServiceClient interface {
	GetActor(ctx context.Context, in *GetActorRequest, opts ...grpc.CallOption) (*Actor, error)
	ListActors(ctx context.Context, in *ListActorsRequest, opts ...grpc.CallOption) (*ListActorsResponse, error)
	ListActorsByFilm(ctx context.Context, in *ListActorsByFilmRequest, opts ...grpc.CallOption) (*ListActorsResponse, error)
	CreateActor(ctx context.Context, in *CreateActorRequest, opts ...grpc.CallOption) (*Actor, error)
	UpdateActor(ctx context.Context, in *UpdateActorRequest, opts ...grpc.CallOption) (*Actor, error)
	DeleteActor(ctx context.Context, in *DeleteActorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type actorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewActorServiceClient(cc grpc.ClientConnInterface) ActorServiceClient {
	return &actorServiceClient{cc}
}

func (c *actorServiceClient) GetActor(ctx context.Context, in *GetActorRequest, opts ...grpc.CallOption) (*Actor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Actor)
	err := c.cc.Invoke(ctx, ActorService_GetActor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorServiceClient) ListActors(ctx context.Context, in *ListActorsRequest, opts ...grpc.CallOption) (*ListActorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListActorsResponse)
	err := c.cc.Invoke(ctx, ActorService_ListActors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorServiceClient) ListActorsByFilm(ctx context.Context, in *ListActorsByFilmRequest, opts ...grpc.CallOption) (*ListActorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListActorsResponse)
	err := c.cc.Invoke(ctx, ActorService_ListActorsByFilm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorServiceClient) CreateActor(ctx context.Context, in *CreateActorRequest, opts ...grpc.CallOption) (*Actor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Actor)
	err := c.cc.Invoke(ctx, ActorService_CreateActor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorServiceClient) UpdateActor(ctx context.Context, in *UpdateActorRequest, opts ...grpc.CallOption) (*Actor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Actor)
	err := c.cc.Invoke(ctx, ActorService_UpdateActor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorServiceClient) DeleteActor(ctx context.Context, in *DeleteActorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ActorService_DeleteActor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActorServiceServer is the server API for ActorService service.
// All implementations must embed UnimplementedActorServiceServer
// for forward compatibility.
//
// ActorService manages actors.
type ActorServiceServer interface {
	GetActor(context.Context, *GetActorRequest) (*Actor, error)
	ListActors(context.Context, *ListActorsRequest) (*ListActorsResponse, error)
	ListActorsByFilm(context.Context, *ListActorsByFilmRequest) (*ListActorsResponse, error)
	CreateActor(context.Context, *CreateActorRequest) (*Actor, error)
	UpdateActor(context.Context, *UpdateActorRequest) (*Actor, error)
	DeleteActor(context.Context, *DeleteActorRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedActorServiceServer()
}

// UnimplementedActorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedActorServiceServer struct{}

func (UnimplementedActorServiceServer) GetActor(context.Context, *GetActorRequest) (*Actor, error) {
	return nil, status.Error(codes.Unimplemented, "method GetActor not implemented")
}
func (UnimplementedActorServiceServer) ListActors(context.Context, *ListActorsRequest) (*ListActorsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListActors not implemented")
}
func (UnimplementedActorServiceServer) ListActorsByFilm(context.Context, *ListActorsByFilmRequest) (*ListActorsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListActorsByFilm not implemented")
}
func (UnimplementedActorServiceServer) CreateActor(context.Context, *CreateActorRequest) (*Actor, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateActor not implemented")
}
func (UnimplementedActorServiceServer) UpdateActor(context.Context, *UpdateActorRequest) (*Actor, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateActor not implemented")
}
func (UnimplementedActorServiceServer) DeleteActor(context.Context, *DeleteActorRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteActor not implemented")
}
func (UnimplementedActorServiceServer) mustEmbedUnimplementedActorServiceServer() {}
func (UnimplementedActorServiceServer) testEmbeddedByValue()                      {}

// UnsafeActorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ActorServiceServer will
// result in compilation errors.
type UnsafeActorServiceServer interface {
	mustEmbedUnimplementedActorServiceServer()
}

func RegisterActorServiceServer(s grpc.ServiceRegistrar, srv ActorServiceServer) {
	// If the following call panics, it indicates UnimplementedActorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ActorService_ServiceDesc, srv)
}

func _ActorService_GetActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorServiceServer).GetActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActorService_GetActor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorServiceServer).GetActor(ctx, req.(*GetActorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorService_ListActors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorServiceServer).ListActors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActorService_ListActors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorServiceServer).ListActors(ctx, req.(*ListActorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorService_ListActorsByFilm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActorsByFilmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorServiceServer).ListActorsByFilm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActorService_ListActorsByFilm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorServiceServer).ListActorsByFilm(ctx, req.(*ListActorsByFilmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorService_CreateActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateActorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorServiceServer).CreateActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActorService_CreateActor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorServiceServer).CreateActor(ctx, req.(*CreateActorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorService_UpdateActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateActorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorServiceServer).UpdateActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActorService_UpdateActor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorServiceServer).UpdateActor(ctx, req.(*UpdateActorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorService_DeleteActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteActorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorServiceServer).DeleteActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActorService_DeleteActor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorServiceServer).DeleteActor(ctx, req.(*DeleteActorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ActorService_ServiceDesc is the grpc.ServiceDesc for ActorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ActorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "film.v1.ActorService",
	HandlerType: (*ActorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActor",
			Handler:    _ActorService_GetActor_Handler,
		},
		{
			MethodName: "ListActors",
			Handler:    _ActorService_ListActors_Handler,
		},
		{
			MethodName: "ListActorsByFilm",
			Handler:    _ActorService_ListActorsByFilm_Handler,
		},
		{
			MethodName: "CreateActor",
			Handler:    _ActorService_CreateActor_Handler,
		},
		{
			MethodName: "UpdateActor",
			Handler:    _ActorService_UpdateActor_Handler,
		},
		{
			MethodName: "DeleteActor",
			Handler:    _ActorService_DeleteActor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "film/v1/film.proto",
}

const (
	CategoryService_GetCategory_FullMethodName    = "/film.v1.CategoryService/GetCategory"
	CategoryService_ListCategories_FullMethodName = "/film.v1.CategoryService/ListCategories"
)

// CategoryServiceClient is the client API for CategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CategoryService provides read-only access to film categories.
type CategoryServiceClient interface {
	GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*Category, error)
	ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error)
}

type categoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCategoryServiceClient(cc grpc.ClientConnInterface) CategoryServiceClient {
	return &categoryServiceClient{cc}
}

func (c *categoryServiceClient) GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*Category, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Category)
	err := c.cc.Invoke(ctx, CategoryService_GetCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCategoriesResponse)
	err := c.cc.Invoke(ctx, CategoryService_ListCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CategoryServiceServer is the server API for CategoryService service.
// All implementations must embed UnimplementedCategoryServiceServer
// for forward compatibility.
//
// CategoryService provides read-only access to film categories.
type CategoryServiceServer interface {
	GetCategory(context.Context, *GetCategoryRequest) (*Category, error)
	ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error)
	mustEmbedUnimplementedCategoryServiceServer()
}

// UnimplementedCategoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCategoryServiceServer struct{}

func (UnimplementedCategoryServiceServer) GetCategory(context.Context, *GetCategoryRequest) (*Category, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCategory not implemented")
}
func (UnimplementedCategoryServiceServer) ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCategories not implemented")
}
func (UnimplementedCategoryServiceServer) mustEmbedUnimplementedCategoryServiceServer() {}
func (UnimplementedCategoryServiceServer) testEmbeddedByValue()                         {}

// UnsafeCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServiceServer will
// result in compilation errors.
type UnsafeCategoryServiceServer interface {
	mustEmbedUnimplementedCategoryServiceServer()
}

func RegisterCategoryServiceServer(s grpc.ServiceRegistrar, srv CategoryServiceServer) {
	// If the following call panics, it indicates UnimplementedCategoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CategoryService_ServiceDesc, srv)
}

func _CategoryService_GetCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategory(ctx, req.(*GetCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_ListCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).ListCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_ListCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).ListCategories(ctx, req.(*ListCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CategoryService_ServiceDesc is the grpc.ServiceDesc for CategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "film.v1.CategoryService",
	HandlerType: (*CategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCategory",
			Handler:    _CategoryService_GetCategory_Handler,
		},
		{
			MethodName: "ListCategories",
			Handler:    _CategoryService_ListCategories_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "film/v1/film.proto",
}

const (
	LanguageService_GetLanguage_FullMethodName   = "/film.v1.LanguageService/GetLanguage"
	LanguageService_ListLanguages_FullMethodName = "/film.v1.LanguageService/ListLanguages"
)

// LanguageServiceClient is the client API for LanguageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// LanguageService provides read-only access to languages.
type LanguageServiceClient interface {
	GetLanguage(ctx context.Context, in *GetLanguageRequest, opts ...grpc.CallOption) (*Language, error)
	ListLanguages(ctx context.Context, in *ListLanguagesRequest, opts ...grpc.CallOption) (*ListLanguagesResponse, error)
}

type languageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLanguageServiceClient(cc grpc.ClientConnInterface) LanguageServiceClient {
	return &languageServiceClient{cc}
}

func (c *languageServiceClient) GetLanguage(ctx context.Context, in *GetLanguageRequest, opts ...grpc.CallOption) (*Language, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Language)
	err := c.cc.Invoke(ctx, LanguageService_GetLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServiceClient) ListLanguages(ctx context.Context, in *ListLanguagesRequest, opts ...grpc.CallOption) (*ListLanguagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLanguagesResponse)
	err := c.cc.Invoke(ctx, LanguageService_ListLanguages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LanguageServiceServer is the server API for LanguageService service.
// All implementations must embed UnimplementedLanguageServiceServer
// for forward compatibility.
//
// LanguageService provides read-only access to languages.
type LanguageServiceServer interface {
	GetLanguage(context.Context, *GetLanguageRequest) (*Language, error)
	ListLanguages(context.Context, *ListLanguagesRequest) (*ListLanguagesResponse, error)
	mustEmbedUnimplementedLanguageServiceServer()
}

// UnimplementedLanguageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLanguageServiceServer struct{}

func (UnimplementedLanguageServiceServer) GetLanguage(context.Context, *GetLanguageRequest) (*Language, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLanguage not implemented")
}
func (UnimplementedLanguageServiceServer) ListLanguages(context.Context, *ListLanguagesRequest) (*ListLanguagesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListLanguages not implemented")
}
func (UnimplementedLanguageServiceServer) mustEmbedUnimplementedLanguageServiceServer() {}
func (UnimplementedLanguageServiceServer) testEmbeddedByValue()                         {}

// UnsafeLanguageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LanguageServiceServer will
// result in compilation errors.
type UnsafeLanguageServiceServer interface {
	mustEmbedUnimplementedLanguageServiceServer()
}

func RegisterLanguageServiceServer(s grpc.ServiceRegistrar, srv LanguageServiceServer) {
	// If the following call panics, it indicates UnimplementedLanguageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LanguageService_ServiceDesc, srv)
}

func _LanguageService_GetLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLanguageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServiceServer).GetLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageService_GetLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServiceServer).GetLanguage(ctx, req.(*GetLanguageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageService_ListLanguages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLanguagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServiceServer).ListLanguages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageService_ListLanguages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServiceServer).ListLanguages(ctx, req.(*ListLanguagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LanguageService_ServiceDesc is the grpc.ServiceDesc for LanguageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LanguageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "film.v1.LanguageService",
	HandlerType: (*LanguageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLanguage",
			Handler:    _LanguageService_GetLanguage_Handler,
		},
		{
			MethodName: "ListLanguages",
			Handler:    _LanguageService_ListLanguages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "film/v1/film.proto",
}
