// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: staff.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveStaff = `-- name: CountActiveStaff :one
SELECT count(*) FROM staff WHERE active = true
`

func (q *Queries) CountActiveStaff(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveStaff)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActiveStaffByStore = `-- name: CountActiveStaffByStore :one
SELECT count(*) FROM staff WHERE store_id = $1 AND active = true
`

func (q *Queries) CountActiveStaffByStore(ctx context.Context, storeID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveStaffByStore, storeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStaff = `-- name: CountStaff :one
SELECT count(*) FROM staff
`

func (q *Queries) CountStaff(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countStaff)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStaffByStore = `-- name: CountStaffByStore :one
SELECT count(*) FROM staff WHERE store_id = $1
`

func (q *Queries) CountStaffByStore(ctx context.Context, storeID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countStaffByStore, storeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStaff = `-- name: CreateStaff :one
INSERT INTO staff (first_name, last_name, address_id, email, store_id, username, password_hash)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING staff_id, first_name, last_name, address_id, email,
          store_id, active, username, last_update
`

type CreateStaffParams struct {
	FirstName    string      `json:"first_name"`
	LastName     string      `json:"last_name"`
	AddressID    int32       `json:"address_id"`
	Email        pgtype.Text `json:"email"`
	StoreID      int32       `json:"store_id"`
	Username     string      `json:"username"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

type CreateStaffRow struct {
	StaffID    int32              `json:"staff_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	AddressID  int32              `json:"address_id"`
	Email      pgtype.Text        `json:"email"`
	StoreID    int32              `json:"store_id"`
	Active     bool               `json:"active"`
	Username   string             `json:"username"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) CreateStaff(ctx context.Context, arg CreateStaffParams) (CreateStaffRow, error) {
	row := q.db.QueryRow(ctx, createStaff,
		arg.FirstName,
		arg.LastName,
		arg.AddressID,
		arg.Email,
		arg.StoreID,
		arg.Username,
		arg.PasswordHash,
	)
	var i CreateStaffRow
	err := row.Scan(
		&i.StaffID,
		&i.FirstName,
		&i.LastName,
		&i.AddressID,
		&i.Email,
		&i.StoreID,
		&i.Active,
		&i.Username,
		&i.LastUpdate,
	)
	return i, err
}

const deactivateStaff = `-- name: DeactivateStaff :one
UPDATE staff
SET active = false
WHERE staff_id = $1
RETURNING staff_id, first_name, last_name, address_id, email,
          store_id, active, username, last_update
`

type DeactivateStaffRow struct {
	StaffID    int32              `json:"staff_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	AddressID  int32              `json:"address_id"`
	Email      pgtype.Text        `json:"email"`
	StoreID    int32              `json:"store_id"`
	Active     bool               `json:"active"`
	Username   string             `json:"username"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) DeactivateStaff(ctx context.Context, staffID int32) (DeactivateStaffRow, error) {
	row := q.db.QueryRow(ctx, deactivateStaff, staffID)
	var i DeactivateStaffRow
	err := row.Scan(
		&i.StaffID,
		&i.FirstName,
		&i.LastName,
		&i.AddressID,
		&i.Email,
		&i.StoreID,
		&i.Active,
		&i.Username,
		&i.LastUpdate,
	)
	return i, err
}

const getStaff = `-- name: GetStaff :one
SELECT staff_id, first_name, last_name, address_id, email,
       store_id, active, username, last_update, picture
FROM staff
WHERE staff_id = $1
`

type GetStaffRow struct {
	StaffID    int32              `json:"staff_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	AddressID  int32              `json:"address_id"`
	Email      pgtype.Text        `json:"email"`
	StoreID    int32              `json:"store_id"`
	Active     bool               `json:"active"`
	Username   string             `json:"username"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
	Picture    []byte             `json:"picture"`
}

// Returns full staff record including picture (but not password_hash).
func (q *Queries) GetStaff(ctx context.Context, staffID int32) (GetStaffRow, error) {
	row := q.db.QueryRow(ctx, getStaff, staffID)
	var i GetStaffRow
	err := row.Scan(
		&i.StaffID,
		&i.FirstName,
		&i.LastName,
		&i.AddressID,
		&i.Email,
		&i.StoreID,
		&i.Active,
		&i.Username,
		&i.LastUpdate,
		&i.Picture,
	)
	return i, err
}

const getStaffByUsername = `-- name: GetStaffByUsername :one
SELECT staff_id, first_name, last_name, address_id, email,
       store_id, active, username, password_hash, last_update
FROM staff
WHERE username = $1
`

type GetStaffByUsernameRow struct {
	StaffID      int32              `json:"staff_id"`
	FirstName    string             `json:"first_name"`
	LastName     string             `json:"last_name"`
	AddressID    int32              `json:"address_id"`
	Email        pgtype.Text        `json:"email"`
	StoreID      int32              `json:"store_id"`
	Active       bool               `json:"active"`
	Username     string             `json:"username"`
	PasswordHash pgtype.Text        `json:"password_hash"`
	LastUpdate   pgtype.Timestamptz `json:"last_update"`
}

// Returns staff record with password_hash for authentication (but not picture).
func (q *Queries) GetStaffByUsername(ctx context.Context, username string) (GetStaffByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getStaffByUsername, username)
	var i GetStaffByUsernameRow
	err := row.Scan(
		&i.StaffID,
		&i.FirstName,
		&i.LastName,
		&i.AddressID,
		&i.Email,
		&i.StoreID,
		&i.Active,
		&i.Username,
		&i.PasswordHash,
		&i.LastUpdate,
	)
	return i, err
}

const listActiveStaff = `-- name: ListActiveStaff :many
SELECT staff_id, first_name, last_name, address_id, email,
       store_id, active, username, last_update
FROM staff
WHERE active = true
ORDER BY staff_id
LIMIT $1 OFFSET $2
`

type ListActiveStaffParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListActiveStaffRow struct {
	StaffID    int32              `json:"staff_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	AddressID  int32              `json:"address_id"`
	Email      pgtype.Text        `json:"email"`
	StoreID    int32              `json:"store_id"`
	Active     bool               `json:"active"`
	Username   string             `json:"username"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) ListActiveStaff(ctx context.Context, arg ListActiveStaffParams) ([]ListActiveStaffRow, error) {
	rows, err := q.db.Query(ctx, listActiveStaff, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveStaffRow{}
	for rows.Next() {
		var i ListActiveStaffRow
		if err := rows.Scan(
			&i.StaffID,
			&i.FirstName,
			&i.LastName,
			&i.AddressID,
			&i.Email,
			&i.StoreID,
			&i.Active,
			&i.Username,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveStaffByStore = `-- name: ListActiveStaffByStore :many
SELECT staff_id, first_name, last_name, address_id, email,
       store_id, active, username, last_update
FROM staff
WHERE store_id = $1 AND active = true
ORDER BY staff_id
LIMIT $2 OFFSET $3
`

type ListActiveStaffByStoreParams struct {
	StoreID int32 `json:"store_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type ListActiveStaffByStoreRow struct {
	StaffID    int32              `json:"staff_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	AddressID  int32              `json:"address_id"`
	Email      pgtype.Text        `json:"email"`
	StoreID    int32              `json:"store_id"`
	Active     bool               `json:"active"`
	Username   string             `json:"username"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) ListActiveStaffByStore(ctx context.Context, arg ListActiveStaffByStoreParams) ([]ListActiveStaffByStoreRow, error) {
	rows, err := q.db.Query(ctx, listActiveStaffByStore, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveStaffByStoreRow{}
	for rows.Next() {
		var i ListActiveStaffByStoreRow
		if err := rows.Scan(
			&i.StaffID,
			&i.FirstName,
			&i.LastName,
			&i.AddressID,
			&i.Email,
			&i.StoreID,
			&i.Active,
			&i.Username,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaff = `-- name: ListStaff :many
SELECT staff_id, first_name, last_name, address_id, email,
       store_id, active, username, last_update
FROM staff
ORDER BY staff_id
LIMIT $1 OFFSET $2
`

type ListStaffParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListStaffRow struct {
	StaffID    int32              `json:"staff_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	AddressID  int32              `json:"address_id"`
	Email      pgtype.Text        `json:"email"`
	StoreID    int32              `json:"store_id"`
	Active     bool               `json:"active"`
	Username   string             `json:"username"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
}

// Returns staff list without picture or password_hash.
func (q *Queries) ListStaff(ctx context.Context, arg ListStaffParams) ([]ListStaffRow, error) {
	rows, err := q.db.Query(ctx, listStaff, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStaffRow{}
	for rows.Next() {
		var i ListStaffRow
		if err := rows.Scan(
			&i.StaffID,
			&i.FirstName,
			&i.LastName,
			&i.AddressID,
			&i.Email,
			&i.StoreID,
			&i.Active,
			&i.Username,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffByStore = `-- name: ListStaffByStore :many
SELECT staff_id, first_name, last_name, address_id, email,
       store_id, active, username, last_update
FROM staff
WHERE store_id = $1
ORDER BY staff_id
LIMIT $2 OFFSET $3
`

type ListStaffByStoreParams struct {
	StoreID int32 `json:"store_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type ListStaffByStoreRow struct {
	StaffID    int32              `json:"staff_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	AddressID  int32              `json:"address_id"`
	Email      pgtype.Text        `json:"email"`
	StoreID    int32              `json:"store_id"`
	Active     bool               `json:"active"`
	Username   string             `json:"username"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) ListStaffByStore(ctx context.Context, arg ListStaffByStoreParams) ([]ListStaffByStoreRow, error) {
	rows, err := q.db.Query(ctx, listStaffByStore, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStaffByStoreRow{}
	for rows.Next() {
		var i ListStaffByStoreRow
		if err := rows.Scan(
			&i.StaffID,
			&i.FirstName,
			&i.LastName,
			&i.AddressID,
			&i.Email,
			&i.StoreID,
			&i.Active,
			&i.Username,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStaff = `-- name: UpdateStaff :one
UPDATE staff
SET first_name = $2, last_name = $3, address_id = $4,
    email = $5, store_id = $6, username = $7
WHERE staff_id = $1
RETURNING staff_id, first_name, last_name, address_id, email,
          store_id, active, username, last_update
`

type UpdateStaffParams struct {
	StaffID   int32       `json:"staff_id"`
	FirstName string      `json:"first_name"`
	LastName  string      `json:"last_name"`
	AddressID int32       `json:"address_id"`
	Email     pgtype.Text `json:"email"`
	StoreID   int32       `json:"store_id"`
	Username  string      `json:"username"`
}

type UpdateStaffRow struct {
	StaffID    int32              `json:"staff_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	AddressID  int32              `json:"address_id"`
	Email      pgtype.Text        `json:"email"`
	StoreID    int32              `json:"store_id"`
	Active     bool               `json:"active"`
	Username   string             `json:"username"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) UpdateStaff(ctx context.Context, arg UpdateStaffParams) (UpdateStaffRow, error) {
	row := q.db.QueryRow(ctx, updateStaff,
		arg.StaffID,
		arg.FirstName,
		arg.LastName,
		arg.AddressID,
		arg.Email,
		arg.StoreID,
		arg.Username,
	)
	var i UpdateStaffRow
	err := row.Scan(
		&i.StaffID,
		&i.FirstName,
		&i.LastName,
		&i.AddressID,
		&i.Email,
		&i.StoreID,
		&i.Active,
		&i.Username,
		&i.LastUpdate,
	)
	return i, err
}

const updateStaffPassword = `-- name: UpdateStaffPassword :exec
UPDATE staff
SET password_hash = $2
WHERE staff_id = $1
`

type UpdateStaffPasswordParams struct {
	StaffID      int32       `json:"staff_id"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) UpdateStaffPassword(ctx context.Context, arg UpdateStaffPasswordParams) error {
	_, err := q.db.Exec(ctx, updateStaffPassword, arg.StaffID, arg.PasswordHash)
	return err
}
