// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customer.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCustomers = `-- name: CountCustomers :one
SELECT count(*) FROM customer
`

func (q *Queries) CountCustomers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCustomersByStore = `-- name: CountCustomersByStore :one
SELECT count(*) FROM customer WHERE store_id = $1
`

func (q *Queries) CountCustomersByStore(ctx context.Context, storeID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomersByStore, storeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customer (store_id, first_name, last_name, email, address_id, activebool, active)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING customer_id, store_id, first_name, last_name, email,
          address_id, activebool, create_date, last_update, active
`

type CreateCustomerParams struct {
	StoreID    int32       `json:"store_id"`
	FirstName  string      `json:"first_name"`
	LastName   string      `json:"last_name"`
	Email      pgtype.Text `json:"email"`
	AddressID  int32       `json:"address_id"`
	Activebool bool        `json:"activebool"`
	Active     pgtype.Int4 `json:"active"`
}

type CreateCustomerRow struct {
	CustomerID int32              `json:"customer_id"`
	StoreID    int32              `json:"store_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
	AddressID  int32              `json:"address_id"`
	Activebool bool               `json:"activebool"`
	CreateDate pgtype.Date        `json:"create_date"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
	Active     pgtype.Int4        `json:"active"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (CreateCustomerRow, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.StoreID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.AddressID,
		arg.Activebool,
		arg.Active,
	)
	var i CreateCustomerRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.AddressID,
		&i.Activebool,
		&i.CreateDate,
		&i.LastUpdate,
		&i.Active,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customer WHERE customer_id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, customerID int32) error {
	_, err := q.db.Exec(ctx, deleteCustomer, customerID)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT customer_id, store_id, first_name, last_name, email,
       address_id, activebool, create_date, last_update, active
FROM customer
WHERE customer_id = $1
`

type GetCustomerRow struct {
	CustomerID int32              `json:"customer_id"`
	StoreID    int32              `json:"store_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
	AddressID  int32              `json:"address_id"`
	Activebool bool               `json:"activebool"`
	CreateDate pgtype.Date        `json:"create_date"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
	Active     pgtype.Int4        `json:"active"`
}

func (q *Queries) GetCustomer(ctx context.Context, customerID int32) (GetCustomerRow, error) {
	row := q.db.QueryRow(ctx, getCustomer, customerID)
	var i GetCustomerRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.AddressID,
		&i.Activebool,
		&i.CreateDate,
		&i.LastUpdate,
		&i.Active,
	)
	return i, err
}

const listCustomers = `-- name: ListCustomers :many
SELECT customer_id, store_id, first_name, last_name, email,
       address_id, activebool, create_date, last_update, active
FROM customer
ORDER BY customer_id
LIMIT $1 OFFSET $2
`

type ListCustomersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCustomersRow struct {
	CustomerID int32              `json:"customer_id"`
	StoreID    int32              `json:"store_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
	AddressID  int32              `json:"address_id"`
	Activebool bool               `json:"activebool"`
	CreateDate pgtype.Date        `json:"create_date"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
	Active     pgtype.Int4        `json:"active"`
}

func (q *Queries) ListCustomers(ctx context.Context, arg ListCustomersParams) ([]ListCustomersRow, error) {
	rows, err := q.db.Query(ctx, listCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCustomersRow{}
	for rows.Next() {
		var i ListCustomersRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.StoreID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.AddressID,
			&i.Activebool,
			&i.CreateDate,
			&i.LastUpdate,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomersByStore = `-- name: ListCustomersByStore :many
SELECT customer_id, store_id, first_name, last_name, email,
       address_id, activebool, create_date, last_update, active
FROM customer
WHERE store_id = $1
ORDER BY customer_id
LIMIT $2 OFFSET $3
`

type ListCustomersByStoreParams struct {
	StoreID int32 `json:"store_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type ListCustomersByStoreRow struct {
	CustomerID int32              `json:"customer_id"`
	StoreID    int32              `json:"store_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
	AddressID  int32              `json:"address_id"`
	Activebool bool               `json:"activebool"`
	CreateDate pgtype.Date        `json:"create_date"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
	Active     pgtype.Int4        `json:"active"`
}

func (q *Queries) ListCustomersByStore(ctx context.Context, arg ListCustomersByStoreParams) ([]ListCustomersByStoreRow, error) {
	rows, err := q.db.Query(ctx, listCustomersByStore, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCustomersByStoreRow{}
	for rows.Next() {
		var i ListCustomersByStoreRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.StoreID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.AddressID,
			&i.Activebool,
			&i.CreateDate,
			&i.LastUpdate,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customer
SET store_id = $2,
    first_name = $3,
    last_name = $4,
    email = $5,
    address_id = $6,
    activebool = $7,
    active = $8
WHERE customer_id = $1
RETURNING customer_id, store_id, first_name, last_name, email,
          address_id, activebool, create_date, last_update, active
`

type UpdateCustomerParams struct {
	CustomerID int32       `json:"customer_id"`
	StoreID    int32       `json:"store_id"`
	FirstName  string      `json:"first_name"`
	LastName   string      `json:"last_name"`
	Email      pgtype.Text `json:"email"`
	AddressID  int32       `json:"address_id"`
	Activebool bool        `json:"activebool"`
	Active     pgtype.Int4 `json:"active"`
}

type UpdateCustomerRow struct {
	CustomerID int32              `json:"customer_id"`
	StoreID    int32              `json:"store_id"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
	AddressID  int32              `json:"address_id"`
	Activebool bool               `json:"activebool"`
	CreateDate pgtype.Date        `json:"create_date"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
	Active     pgtype.Int4        `json:"active"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (UpdateCustomerRow, error) {
	row := q.db.QueryRow(ctx, updateCustomer,
		arg.CustomerID,
		arg.StoreID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.AddressID,
		arg.Activebool,
		arg.Active,
	)
	var i UpdateCustomerRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.AddressID,
		&i.Activebool,
		&i.CreateDate,
		&i.LastUpdate,
		&i.Active,
	)
	return i, err
}
